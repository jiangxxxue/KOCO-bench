{
  "meta": {
    "repository": "trackerLab",
    "target_domains": [
      "物理仿真",
      "运动重定向",
      "位置变换",
      "骨骼动画",
      "运动跟踪",
      "电机模型",
      "跨仿真器迁移"
    ],
    "generation_focus": "严格的高层次领域知识问题。零琐碎内容。",
    "total_problems": 17,
    "single_answer_count": 3,
    "multiple_answer_count": 14
  },
  "problems": [
    {
      "id": 2,
      "dataset": "trackerLab",
      "instruction": "选择多个选项",
      "stem": "在通过Sim2SimLib将策略从IsaacLab迁移到MuJoCo的背景下，两个仿真器之间的哪些架构差异需要观测和动作映射层？\n\n- (A) IsaacLab使用GPU加速的并行环境，而MuJoCo运行单线程CPU仿真\n- (B) IsaacLab URDF导入和MuJoCo XML定义之间的关节排序和命名约定不同\n- (C) IsaacLab在世界坐标系中提供观测，而MuJoCo默认使用以身体为中心的坐标系\n- (D) 两个仿真器使用不同的接触模型（基于惩罚与基于约束），影响地面反作用力\n- (E) IsaacLab的关节API返回的数据张量形状与MuJoCo的mjData结构不同",
      "explanation": "(B)、(C)和(E)正确。这测试了对`sim2simlib/model/sim2sim_base.py`、`sim2simlib/model/config.py`和关节映射系统中跨仿真器迁移挑战的深入理解。(B)至关重要——Sim2SimLib中的`policy_joint_names`配置和关节重排序逻辑直接解决了这个问题。(C)反映了需要重力方向变换的坐标系约定差异。(E)捕获了需要观测重塑的数据结构不匹配。(A)是性能差异，而不是架构映射要求。(D)影响物理保真度，但不需要观测/动作重映射——尽管接触求解器不同，两个仿真器都可以产生类似的观测。",
      "gt": [
        "B",
        "C",
        "E"
      ]
    },
    {
      "id": 4,
      "dataset": "trackerLab",
      "instruction": "选择多个选项",
      "stem": "在Sim2SimLib中的DC电机模型实现中，速度相关扭矩限制公式捕获了哪些物理现象？\n\n- (A) 反电动势随着电机速度增加而减少可用电压\n- (B) 库仑摩擦在更高速度下转变为粘性摩擦\n- (C) 热限制导致在持续高速下扭矩降额\n- (D) DC电机中的基本扭矩-速度权衡，其中最大扭矩出现在堵转时\n- (E) 齿轮间隙效应在更高角速度下变得更加明显",
      "explanation": "(A)和(D)正确。这测试了`sim2simlib/model/actuator_motor.py`中的电机建模领域知识。DC电机模型使用：τ_max(q̇) = τ_sat * (1 - |v_ratio|)，其中v_ratio = q̇/q̇_max。这捕获了(A)反电动势：随着电机旋转更快，反电动势对抗施加的电压，减少电流从而减少扭矩。(D)是宏观表现：零速度（堵转）时最大扭矩，线性减少到最大速度时的零扭矩。(B)不正确——摩擦与扭矩-速度曲线分离。(C)此公式中未建模热效应。(E)间隙是位置域现象，不由速度相关限制捕获。",
      "gt": [
        "A",
        "D"
      ]
    },
    {
      "id": 6,
      "dataset": "trackerLab",
      "instruction": "选择多个选项",
      "stem": "SkillGraph构建了一个补丁级转换图，其中技能内转换的成本为零，而技能间转换具有计算的成本。这种成本结构支持哪些设计原则？\n\n- (A) 分层运动规划，其中高级策略选择技能，低级跟踪遵循补丁\n- (B) 基于自然运动边界的自动运动分割\n- (C) 偏好在转换之前完成已启动的技能，减少运动碎片化\n- (D) 使用可微分图遍历的技能序列的基于梯度的优化\n- (E) 使用图搜索算法进行技能组合的高效最短路径规划",
      "explanation": "(A)、(C)和(E)正确。这测试了对`trackerLab/managers/skill_manager/skill_graph.py`和`skill_manager.py`中技能组合架构的理解。(A)是可能的，因为零技能内成本为分层分解创建了自然的技能边界。(C)直接遵循——一旦进入技能，零成本的顺序补丁鼓励在昂贵的技能间转换之前完成。(E)正确——成本结构使Dijkstra或A*能够找到最优技能序列。(B)不正确——分割是预定义的，不是从成本自动生成的。(D)错误——图使用离散成本，不可微分用于基于梯度的优化。",
      "gt": [
        "A",
        "C",
        "E"
      ]
    },
    {
      "id": 8,
      "dataset": "trackerLab",
      "instruction": "选择多个选项",
      "stem": "在MotionLib中计算身体坐标系归一化运动项（lvbs、ltbs、avbs）时，应用了哪些坐标变换？\n\n- (A) 逆四元数旋转将全局速度转换到根身体坐标系\n- (B) 减去根位置以获得相对平移\n- (C) 与根方向的叉积以计算角动量\n- (D) 四元数共轭乘法以在局部坐标中表达向量\n- (E) 投影到地平面以去除垂直分量",
      "explanation": "(A)和(D)正确（它们描述相同的操作）。这测试了`trackerLab/motion_buffer/motion_lib/motion_lib.py`和`poselib/core/rotation3d.py`中的变换数学。代码使用quat_apply_inverse(root_rot, global_vector)，它应用逆旋转（单位四元数的四元数共轭）将全局坐标系向量转换到身体坐标系。(B)不正确——平移归一化使用逆旋转，而不是减法。(C)错误——这里不计算角动量。(E)错误——这些变换中不发生地平面投影。",
      "gt": [
        "A",
        "D"
      ]
    },
    {
      "id": 10,
      "dataset": "trackerLab",
      "instruction": "选择多个选项",
      "stem": "MotionManager的calc_current_pose方法为环境重置构造状态字典。哪些设计决策反映了运动跟踪与IsaacLab关节系统之间的集成？\n\n- (A) 关节位置使用id_caster.fill_2lab填充，以处理运动和仿真之间的部分关节覆盖\n- (B) 根姿态将位置和四元数旋转组合在7D向量中，匹配IsaacLab的关节状态格式\n- (C) 速度按仿真时间步长缩放，以从每帧转换为每秒单位\n- (D) 状态字典使用匹配IsaacLab场景图结构的嵌套键（articulation/robot）\n- (E) 初始姿态被克隆并单独存储，以实现基于增量的观测",
      "explanation": "(A)、(B)、(D)和(E)正确。这测试了`trackerLab/managers/motion_manager/motion_manager.py`和IsaacLab关节API的集成架构。(A)至关重要——运动数据可能不覆盖所有仿真关节（例如手），需要选择性填充。(B)匹配IsaacLab的root_pose格式：[x,y,z, qx,qy,qz,qw]。(D)反映了IsaacLab的分层状态结构。(E)使计算相对观测（当前-初始）成为可能。(C)不正确——速度已经是运动数据中的每秒单位。",
      "gt": [
        "A",
        "B",
        "D",
        "E"
      ]
    },
    {
      "id": 12,
      "dataset": "trackerLab",
      "instruction": "选择多个选项",
      "stem": "当SkillManager基于patch_time超过patch_time_curr更新技能时，采用了哪些状态管理策略？\n\n- (A) 补丁时间按patch_time递减而不是重置为零，保留子补丁时序精度\n- (B) 具有目标技能集（env_update_target_skill > 0）的环境在随机转换之前确定性地更新\n- (C) 技能转换策略仅针对没有显式目标技能的环境调用\n- (D) 当任何环境的计时器到期时，所有环境都同步转换\n- (E) 目标技能指示器在成功转换后被清除，以防止重复的强制转换",
      "explanation": "(A)、(B)、(C)和(E)正确。这测试了`trackerLab/managers/skill_manager/skill_manager.py`中的技能转换逻辑。(A)保留时序精度：'self.patch_time_curr[update_envs] -= self.patch_time'保持小数时间。(B)和(C)实现优先级系统：显式目标覆盖随机策略。(E)防止状态损坏：转换后'self.env_update_target_skill[env_ids] = -1'。(D)错误——环境基于各自的计时器独立转换。",
      "gt": [
        "A",
        "B",
        "C",
        "E"
      ]
    },
    {
      "id": 14,
      "dataset": "trackerLab",
      "instruction": "选择多个选项",
      "stem": "在IsaacLab的GPU加速仿真中，MotionManager设计的哪些方面能够在数千个环境中实现高效的并行运动跟踪？\n\n- (A) 所有运动状态张量（loc_root_pos、loc_dof_pos等）都以环境维度优先进行批处理\n- (B) 使用SLERP的帧插值被实现为整个批次上的向量化操作\n- (C) MotionBuffer为所有环境同时预计算运动库索引\n- (D) 关节ID转换使用张量索引操作而不是对各个环境的循环\n- (E) 运动时间更新是每个环境的条件更新，但作为掩码张量操作执行",
      "explanation": "(A)、(B)、(D)和(E)正确。这测试了对`trackerLab/managers/motion_manager/motion_manager.py`和`trackerLab/motion_buffer/`中GPU并行化的理解。(A)启用SIMD操作：张量是[num_envs, ...]。(B) SLERP同时对批处理的四元数进行操作。(D) id_caster使用张量索引：'dof_pos[:, self.gym2lab_dof_ids]'一次处理所有环境。(E) static_motion检查使用掩码更新。(C)不正确——MotionBuffer不预计算索引；它根据当前motion_ids和motion_times动态查询MotionLib。",
      "gt": [
        "A",
        "B",
        "D",
        "E"
      ]
    },
    {
      "id": 15,
      "dataset": "trackerLab",
      "instruction": "选择一个选项",
      "stem": "在Sim2SimLib的观测历史机制中，为什么时间观测堆叠对于从IsaacLab到MuJoCo的策略迁移至关重要？\n\n- (A) MuJoCo的单线程执行需要缓冲观测以进行批处理\n- (B) 使用观测历史训练的策略隐式地从有限差分学习速度和加速度\n- (C) 观测历史补偿MuJoCo相对于IsaacLab较低的仿真频率\n- (D) 历史观测使策略能够检测和纠正仿真偏差",
      "explanation": "(B)正确。这测试了对`sim2simlib/model/config.py`和观测处理中策略架构的理解。当策略使用观测历史训练时（例如，关节位置的最后3个时间步），它们学习提取导数：velocity ≈ (pos_t - pos_{t-1})/dt，acceleration ≈ (vel_t - vel_{t-1})/dt。这至关重要，因为如果IsaacLab训练使用历史但MuJoCo部署不提供它，策略会失去关键的动态信息。必须为迁移维护历史。(A)错误——批处理不是原因。(C)误解——两者可以以相同频率运行。(D)不正确——历史不检测仿真差异。",
      "gt": [
        "B"
      ]
    },
    {
      "id": 16,
      "dataset": "trackerLab",
      "instruction": "选择多个选项",
      "stem": "SkeletonTree类将骨骼拓扑表示为树结构。这种树表示支持哪些运动学计算？\n\n- (A) 正向运动学：通过从父到子遍历从局部旋转计算全局关节位置\n- (B) 逆运动学：在给定期望末端执行器位置的情况下求解关节角度\n- (C) 雅可比计算：计算关节速度与末端执行器速度之间的关系\n- (D) 关节速度传播：从父速度和局部角速度计算子关节速度\n- (E) 质心计算：聚合由全局位置加权的连杆质量",
      "explanation": "(A)、(D)和(E)正确。这测试了`poselib/skeleton/skeleton3d.py`中的骨骼运动学。(A)是基础——树遍历启用FK：child_global_pos = parent_global_pos + parent_global_rot * bone_vector。(D)遵循树：子速度包括父速度加上父角速度的贡献。(E)使用树结构聚合：CoM = Σ(mass_i * global_pos_i) / total_mass。(B)不正确——IK需要优化/搜索，而不仅仅是树结构。(C)错误——雅可比需要显式导数计算，树本身不提供。",
      "gt": [
        "A",
        "D",
        "E"
      ]
    },
    {
      "id": 20,
      "dataset": "trackerLab",
      "instruction": "选择多个选项",
      "stem": "MotionManager的loc_gen_state方法通过在两帧之间插值来计算运动状态。哪些数值考虑影响插值质量？\n\n- (A) SLERP后的四元数归一化以保持单位范数，尽管存在浮点误差\n- (B) 处理四元数双覆盖（q和-q表示相同的旋转）通过选择较短的路径\n- (C) 将混合因子钳制到[0,1]以防止超出帧边界的外推\n- (D) 对旋转计算使用双精度以最小化累积误差\n- (E) 应用时间平滑滤波器以减少插值状态中的高频抖动",
      "explanation": "(B)和(C)正确。这测试了`trackerLab/managers/motion_manager/motion_manager.py`和`trackerLab/utils/torch_utils/slerp`中的数值方法。(B)至关重要——四元数具有双覆盖：q和-q表示相同的旋转。SLERP必须选择较短的弧（点积检查）以避免360°旋转。(C)防止外推：blend = (motion_time - f0_time) / dt应该被钳制。(A)不必要——正确的SLERP保持单位范数。(D)未实现——使用单精度。(E)不是loc_gen_state的一部分。",
      "gt": [
        "B",
        "C"
      ]
    },
    {
      "id": 21,
      "dataset": "trackerLab",
      "instruction": "选择一个选项",
      "stem": "为什么Sim2SimLib实现control_decimation以比仿真时间步长更低的频率运行策略推理？\n\n- (A) 通过避免冗余策略评估来降低计算成本\n- (B) 匹配IsaacLab训练期间使用的控制频率，保持时间一致性\n- (C) 模拟高级规划和低级控制之间的通信延迟\n- (D) 允许PID控制器在策略更新之间有时间稳定",
      "explanation": "(B)正确。这测试了`sim2simlib/model/config.py`和`sim2sim_base.py`中的控制频率匹配。如果IsaacLab训练使用control_decimation=4（策略每4个仿真步骤运行一次），策略学习假设此频率产生动作。在MuJoCo中以不同频率运行会改变时间动力学——动作将保持不同的持续时间，影响策略的行为。匹配训练频率对于迁移至关重要。(A)是副作用，不是主要原因。(C)误解了目的。(D)不正确——无论如何，PID都以仿真频率运行。",
      "gt": [
        "B"
      ]
    },
    {
      "id": 22,
      "dataset": "trackerLab",
      "instruction": "选择多个选项",
      "stem": "在SkeletonMotion类中，支持哪些时间操作用于运动序列操作？\n\n- (A) 使用有限差分从位置序列计算关节速度\n- (B) 时间扭曲以改变运动速度同时保留空间特征\n- (C) 使用动态时间规整对多个运动序列进行时间对齐\n- (D) 帧插值以增加运动帧率\n- (E) 运动混合以在不同运动片段之间创建平滑过渡",
      "explanation": "(A)正确，(D)通过插值方法支持。这测试了`poselib/skeleton/skeleton3d.py`中的SkeletonMotion功能。(A)明确提到：从位置序列'提供计算关节速度的实用程序'。(D)通过插值基础设施支持。(B)时间扭曲未明确实现。(C)未提供DTW。(E)片段之间的运动混合不是SkeletonMotion功能（尽管存在帧级插值）。",
      "gt": [
        "A",
        "D"
      ]
    },
    {
      "id": 24,
      "dataset": "trackerLab",
      "instruction": "选择多个选项",
      "stem": "在SkillGraph中设计技能转换成本函数时，可以使用哪些运动相似性度量来计算技能间转换成本？\n\n- (A) 补丁边界处根身体平移之间的L2距离\n- (B) 补丁边界处根身体方向之间的四元数距离\n- (C) 使用加权关节角度差异的关节配置空间距离\n- (D) 速度曲线之间的动态时间规整距离\n- (E) 全身轨迹曲线之间的Frechet距离",
      "explanation": "(A)、(B)和(C)正确。这测试了`trackerLab/managers/skill_manager/skill_graph/skill_edge.py`中的技能图构建。BUILD_GRAPH_METHODS使用诸如'trans_base'（A-根平移）、方向差异（B）和关节空间距离（C）等度量，具有可配置的范数（L2）和窗口。这些是计算效率高的基于边界的度量。(D) DTW对于实时图构建来说太昂贵。(E)完整轨迹上的Frechet距离计算成本过高，在实现中未使用。",
      "gt": [
        "A",
        "B",
        "C"
      ]
    },
    {
      "id": 25,
      "dataset": "trackerLab",
      "instruction": "选择一个选项",
      "stem": "为什么重定向管道要求源和目标T-pose都处于相同的规范姿态（例如，都处于T-pose）？\n\n- (A) 确保两个骨骼具有相同数量的关节\n- (B) 建立一个公共参考框架，可以在其中比较骨骼方向向量以计算旋转偏移\n- (C) 将骨骼长度归一化为单位向量以进行尺度不变比较\n- (D) 通过确保相应的关节具有相似的名称来简化关节映射",
      "explanation": "(B)正确。这测试了`poselib/retarget/retargeting_processor.py`中的重定向数学。T-pose作为规范配置，我们可以在其中计算对齐相应骨骼所需的旋转偏移。例如，如果源的上臂指向方向v_s，目标的指向方向v_t（都在各自的T-pose中），旋转偏移R满足：R * v_s = v_t。然后将此偏移应用于所有运动帧。两者必须处于相同的姿态类型（T-pose），以便骨骼方向可比较。(A)错误——关节数可以不同。(C)误解——骨骼长度未归一化。(D)不正确——命名与姿态匹配分离。",
      "gt": [
        "B"
      ]
    },
    {
      "id": 26,
      "dataset": "trackerLab",
      "instruction": "选择多个选项",
      "stem": "在MuJoCo的基于约束的接触求解器与IsaacLab的基于惩罚的接触模型中，哪些行为差异影响策略迁移？\n\n- (A) 基于约束的求解器产生无穿透的硬接触，而基于惩罚的允许小穿透\n- (B) 基于约束的求解器可以产生瞬时速度变化，而基于惩罚的产生渐进的力响应\n- (C) 基于约束的求解器是确定性的，而基于惩罚的引入随机接触动力学\n- (D) 基于约束的求解器在碰撞中更好地保持能量守恒\n- (E) 基于约束的求解器需要更小的时间步长以保持稳定性",
      "explanation": "(A)、(B)和(D)正确。这测试了与`sim2simlib/`迁移相关的物理仿真理解。(A)约束求解器通过拉格朗日乘数精确强制非穿透，而惩罚方法使用弹簧-阻尼器力允许小穿透。(B)约束可以产生不连续的速度变化（冲量），而惩罚力平滑积分。(D)约束求解器可以精确强制恢复系数，更好地保持能量。(C)错误——两者都可以是确定性的。(E)相反——由于刚性弹簧，惩罚方法通常需要更小的时间步长。",
      "gt": [
        "A",
        "B",
        "D"
      ]
    },
    {
      "id": 28,
      "dataset": "trackerLab",
      "instruction": "选择多个选项",
      "stem": "JointIdCaster维护gym和lab关节排序之间的映射。哪些场景需要这种双向映射？\n\n- (A) 读取运动数据（gym顺序）并写入IsaacLab仿真状态（lab顺序）\n- (B) 读取IsaacLab观测（lab顺序）并计算运动跟踪误差（gym顺序）\n- (C) 将重定向的关节位置（gym顺序）应用于机器人执行器（lab顺序）\n- (D) 将策略动作（lab顺序）转换为运动库格式以进行日志记录（gym顺序）\n- (E) 在分布式训练工作器之间同步关节状态",
      "explanation": "(A)、(B)和(C)正确。这测试了`trackerLab/joint_id_caster.py`及其在管理器中的使用的双向映射用例。(A)是主要用途：运动数据→仿真。(B)计算跟踪奖励需要：仿真状态→运动参考框架。(C)将重定向数据应用于仿真。(D)不正确——策略动作已经是lab顺序，不需要转换为gym用于日志记录。(E)无关——分布式训练不涉及gym/lab转换。",
      "gt": [
        "A",
        "B",
        "C"
      ]
    },
    {
      "id": 30,
      "dataset": "trackerLab",
      "instruction": "选择多个选项",
      "stem": "当从全局运动数据计算身体坐标系观测（lvbs、avbs）时，这些转换后的量表示哪些物理解释？\n\n- (A) lvbs表示固定在身体上的观察者感知到的根身体速度\n- (B) avbs表示身体局部坐标系中的角速度向量\n- (C) lvbs消除了全局平移的影响，隔离相对运动\n- (D) avbs对身体的全局方向不变，表示内在旋转速率\n- (E) 两个量都在惯性坐标系中表达，但相对于身体的位置",
      "explanation": "(A)、(B)和(D)正确。这测试了对`trackerLab/motion_buffer/motion_lib/motion_lib.py`和`poselib/core/rotation3d.py`中参考坐标系的理解。(A)正确——quat_apply_inverse(root_rot, global_vel)将全局速度转换到身体坐标系，给出身体固定观察者看到的速度。(B)正确——角速度旋转到身体坐标系。(D)是一个关键属性——角速度大小和方向（在身体坐标系中）与全局方向无关。(C)错误——lvbs不消除平移效应，它改变参考坐标系。(E)相反——它们在身体坐标系中，而不是惯性坐标系。",
      "gt": [
        "A",
        "B",
        "D"
      ]
    }
  ]
}